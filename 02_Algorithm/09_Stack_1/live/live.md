## DP
> 동적계획 알고리즘은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘
> 먼저 입력 크기가 작은 부분 문제들을 모두 해결한 후에
> 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여,
> 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘이다.


### 피보나치 수 DP 적용
- 피보나치 수는 부분 문제의 답으로부터 본 문제의 답을 얻을 수 있으므로
최적 부분 구조로 이루어져 있다.
  1. 문제를 부분 문제로 분할한다.
  2. 부분 문제로 나누는 일을 끝냈으면 가장 작은 부분 문제부터 해를 구한다.
  3. 그 결과는 테이블에 저장하고, 테이블에 저장된 부분 문제의 해를 이용하여 상위문제의 해를 구한다.
    
```python
def fibo2(n):
    f = [0] * (n+1)
    f[0] = 0
    f[1] = 1
    for i in range(2, n+1):
        f[i] = f[i-1] + f[i-2]
    return f[n]
```
### DP의 구현방식
- recursive 방식 : 재귀
- iterative 방식 : 반복구조


# DFS(깊이우선탐색)
- 비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요
- 두 가지 방법
 - 깊이 우선 탐색(DFS)
 - 너비 우선 탐색(BFS)

## 깊이 우선 탐색
 : 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 
  없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서
  다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회방법
 : 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을
  반복해야 하므로 후입선출 구조의 스택 사용
 : 재귀를 사용할 수도 있다. 무조건 스택을 사용하는건 깊이 우선탐색이구요~~ 라고 하면 안돼
- 백트레킹이랑, 뒤에 응용에서 또 나올거다

1. 시작 정점 v를 결정하여 방문한다.
2. 정점 v에 인접한 정점 중에서
 - 방문하지 않은 정점 w가 있으면, 정점 v를 스택에 push 하고 정점 w를 방문한다.
    w를 v로 하여 다시 반복한다
   - 방문하지 않은 정점이 없으면, 탐색의 방향을 바꾸기 위해서 스택을 pop하여 받은
    가장 마지막 방문 정점을 v로 하여 다시 반복한다.
     
3. 스택이 공백이 될 때까지 2를 반복한다. 

```python
visited[], stack[] 초기화
DFS(v)
 시작점 v방문;
 visited[v] <- true;
 while {
     if (v의 인접 정점 중 방문 안 한 정점 w가 있으면)
        push(v);
        v <- w; (w에 방문)
        visited[w] <-true;
     else
        if (스택이 비어있지 않으면)
            v <- pop(stack);
        else
            break
 }
end DFS()
```

- 초기 상태 : 배열 visited를 0 또는 False로 초기화하고, 공백 스택을 생성
- 정점 A를 시작으로 깊이 우선 탐색을 시작
  A방문;
  visited[A] <- true;
  
- 정점 A에 방문하지 않은 정점 B,C가 있으므로 A를 스택에 push 하고, 
  인접정점 B와 C 중에서 오름차순에 따라 B를 선택하여 탐색을 계속한다.
  push(A);
  B 방문해서 할거
  visited[B] <- true;
  
- 정점 B에 방문하지 않은 정점 D,E가 있으므로 B를 스택에 push 하고, 
인접정점 D를 선택하여 탐색을 계속한다. 
  