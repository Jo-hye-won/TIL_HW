## SW 문제 해결
## 표준입출력
- 입력
- Raw값의 입력 : input()
  : 받은 입력값을 문자열로 취급

- Evaluated 된 값 입력 : eval(input())
    : 받은 입력값을 평가된 데이터 형으로 취급

- 출력
- print()
- print('text',end='')
- print('%d'% number) => Formatting 된 출력

## 비트 연산
- & : 비트단위로 AND 연산을 한다. (하나라도 0이면 0이다)
        ex. 10110101 & 1111001 => 10110001
        (이렇게 어떠한 자리를 0으로 만들고 싶을때 비트연산 사용)

- | : 비트단위로 OR 연산을 한다.(하나라도 1이면 1이 되는 연산)
        - 특정 비트를 1로 만들고 싶을 때 사용
        ex. 10110000 or 00001000 => 10111000
            (원래의 1의 값은 그대로 유지되고 5번째자리의 0이 1이 됨)
        
        ex2. 1 << 5 or 1 << 3 => 3번 비트와 5번비트가 1인 값

- ^ : 비트단위로 XOR 연산을 한다.(같으면 0 다르면 1)
        ex. 10110000 ^ 00010100
            00010100
           ----------
         => 10100100

- ~ : 단항 연산자로서 피연산자의 모든 비트를 반전시킨다.(0은 1로 1은 0으로)

### 연산자의 기능
- '<<' : 피연산자의 비트 열을 왼쪽으로 이동시킨다.
- '>>' : 피연산자의 비트 열을 오른쪽으로 이동시킨다.


### 1<<2
- 2의 n제곱의 값을 갖는다.
- 원소가 n개일 경우의 모든 부분집합의 수를 의미한다.
- Power set(모든 부분집합)
 - 공집합과 자기 자신을 포함한 모든 부분집합
 - 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 
   모든 부분집합의 수가 계산됨

### i & (1<<j)
 - 계산 결과는 i의 j번째 비트가 1인지 아닌지를 의미한다.

###  비트 연산 예제 1
```bash
def Bbit_print(i):
  output = ""
  for j in range(7, -1, -1):
    output += "1" if i & (1 << j)) else "0"
  print(output)
```