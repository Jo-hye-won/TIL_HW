## 부분집합 합(Subset Sum)
### 부분집합의 수
- 집합의 원소가 n개일 때, 공집합을 포함한 부분집합의 수는 2^n개 이다.
- 이는 각 원소를 부분집합에 포함시키거나 포함시키지 않는 
  2가지 경우를 모든 원소에 적용한 경우의 수와 같다.
  

### 부분집합 생성하기
> 각 원소가 부분집합에 포함되었는지를 loop 이용하여 확인하고 부분집합을 생성하는 방법

```python
bit = [0,0,0,0]
    for i in range(2):
        bit[0] = i  # bit 첫번째 자리에 0또는 1
        for j in range(2):
            bit[1] = j  # bit 두번째 자리에 0또는 1
                for k in range(2):
                    bit[2] = k  # bit 세번째 자리에 0또는 1
                    for l in range(2):
                        bit[3] = l      # bit 네번째 자리에 0또는 1
                        print_subset(bit)
```


## 비트 연산자
1. & : 비트 단위로 and 연산을 함
2. | : 비트 단위로 or 연산을 함
3. << : 피연산자의 비트 열을 왼쪽으로 이동시킨다.
   : 1 << n : 2^n 즉, 원소가 n개일 경우의 모든 부분집합의 수 의미
   : n번 비트가 1인 값
4. '>>' : 피연산자의 비트 열을 오른쪽으로 이동시킨다.
   : i & (1<<j) : i의 j번째 비트가 1인지 아닌지를 검사한다.
   

## 검색
> 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업
- 목적하는 탐색 키를 가진 항목을 찾는 것 
- 탐색 키 = 자료를 구별하여 인식할 수 있는 키
- 순차검색(sequential search), 이진검색 ,해쉬 


## 순차검색
- 가장 간단하고 직관적인 검색 방법
- 배열이나 연결 리스트 등 순차구조로 구현된 자료구조에서 원하는 항목 찾을 때 유용
- 알고리즘이 단순하여 구현이 쉽지만, 검색 대상이 많은 경우 수행시간이 급격히 증가하여 비효율적

### 정렬되어 있지 않은 경우
- 찾고자 하는 원소의 순서에 따라 비교회수가 결정됨
- 첫 번째 원소를 찾을 때는 1번 비교, 두번째 원소를 찾을 때는 2번 비교...

### 정렬되어 있지 않은 경우
- 자료를 순차적으로 검색하면서 키 값을 비교하여, 
  원소의 키값이 검색 대상의 키 값보다 크면 찾는 원소가 없다는 것이므로
  더 이상 검색하지 않고 검색 종료해서
  
- 검색 실패를 반환하는 경우 평균 비교 회수가 반으로 줄어듬


## 이진 검색(Binary Search) ★★★★
 자료의 가운데에 있는 항목의 키 값고 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
 
 목적 키를 찾을 때까지 이진검색을 순환적으로 반복수행함으로써 
 
 검색 범위를 반을 줄여가면서 보다 빠르게 검색을 수행함 
> 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 한다.

### 이진 검색
- 자료의 중앙에 있는 원소를 고른다
- 중앙 원소의 값과 찾고자 하는 목표 값을 비교한다.
- 목표 값이 중앙 원소의 값보다 작으면 자료의 왼쪽 반에 대해서 새로 검색을 수행하고,
- 크다면 자료의 오른쪽 반에 대하여 새로 검색을 수행한다.
- 찾고자 하는 값을 찾을 때까지, 과정을 반복한다.

### 구현
- 검색 범위의 시작점과 종료점을 이용하여 검색을 반복 수행한다
- 이진 검색의 경우, 자료에 삽입이나 삭제가 발생했을 때 배열의 상태를
항상 정렬 상태로 유지하는 추가 작업이 필요하다
  
```python
def binarySearch(a,N,key):
    start = 0
    end = N-1
    while start <= end:     # 탐색 구간이 존재, 원소가 한개 이상이면 탐색해야 함!
        middle = (start + end) // 2
        if a[middle] == key :   # 검색 성공
            return true
        elif a[middle] > key:
            end = middle -1
        else:
            start = middle +1
    return false
```

### 재귀 함수 이용
> 재귀함수를 이용하여 이진 검색을 구현할 수도 있다.
```python
def binarySearch2(a, low, high, key):
    if low > high :
        return False
    


```

## 인덱스
- 원본 데이터에 데이터가 삽입될 경우 상대적으로 크기가 작은 인덱스 배열을
정렬하기 때문에 속도가 빠르다.
  

## 선택 정렬(Selection Sort)
> 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
- 앞서 살펴본 셀렉션 알고리즘을 전체 자료에 적용한 것이다.
- 버블정렬이랑 구분하기

1. 주어진 리스트 중에서 최소값을 찾는다.
2. 그 값을 리스트의 맨 앞에 위치한 값과 교환한다.
3. 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다.


## 셀렉션 알고리즘(Selection Algorithm)
> 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법을 셀렉션 알고리즘이라 한다
- 최소값, 최대값 혹은 중간값을 찾는 알고리즘을 의미하기도 한다.

1. 정렬 알고리즘을 이용하여 자료 정렬하기
2. 원하는 순서에 있는 원소 가져오기

